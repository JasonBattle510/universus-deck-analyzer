<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Universus Deck Analyzer - AI Powered</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        /* Dark Theme - Midnight Teal */
        body.dark {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: #e2e8f0;
            min-height: 100vh;
            transition: background 0.3s ease, color 0.3s ease;
        }
        body.dark .header { background: linear-gradient(135deg, #1e293b 0%, #334155 100%); border: 1px solid #475569; }
        body.dark .title { color: #14b8a6; }
        body.dark .subtitle { color: #cbd5e1; }
        body.dark .status { color: #5eead4; }
        body.dark .tab-active { background: #14b8a6; color: #0f172a; box-shadow: 0 4px 12px rgba(20, 184, 166, 0.4); }
        body.dark .tab-inactive { background: #1e293b; color: #94a3b8; border: 1px solid #475569; }
        body.dark .tab-inactive:hover { background: #334155; color: #cbd5e1; }
        body.dark .card { background: #1e293b; border: 1px solid #475569; }
        body.dark .btn-primary { background: #14b8a6; color: #0f172a; }
        body.dark .btn-primary:hover { background: #5eead4; }
        body.dark .btn-primary:disabled { background: #475569; color: #64748b; }
        body.dark .btn-secondary { background: #334155; color: #cbd5e1; }
        body.dark .btn-secondary:hover { background: #475569; }
        body.dark .btn-success { background: #14b8a6; color: #0f172a; }
        body.dark .alert { background: #1e293b; border-color: #14b8a6; color: #5eead4; }
        body.dark .progress-box { background: #1e293b; border: 1px solid #475569; }
        body.dark .progress-bar { background: #0f172a; }
        body.dark .progress-fill { background: linear-gradient(90deg, #14b8a6, #5eead4); }
        body.dark .smart-box { background: #1e293b; border: 2px solid #14b8a6; }
        body.dark .input, body.dark .textarea { background: #0f172a; border: 1px solid #475569; color: #e2e8f0; }
        body.dark .input:focus, body.dark .textarea:focus { border-color: #14b8a6; box-shadow: 0 0 0 3px rgba(20, 184, 166, 0.1); }
        body.dark .api-key-section { background: #0f172a; border: 2px solid #14b8a6; }
        body.dark .analysis-tab-active { background: #14b8a6; color: #0f172a; }
        body.dark .analysis-tab-inactive { background: #0f172a; color: #94a3b8; border: 1px solid #475569; }
        body.dark .analysis-tab-inactive:hover { background: #334155; color: #cbd5e1; }
        body.dark .analysis { background: #0f172a; color: #cbd5e1; }
        body.dark .analysis h1 { color: #14b8a6; border-bottom: 2px solid #475569; }
        body.dark .analysis h2 { color: #5eead4; }
        body.dark .analysis h3 { color: #5eead4; }
        body.dark .analysis h4 { color: #6ee7b7; }
        body.dark .analysis strong { color: #14b8a6; }
        body.dark .analysis code { background: #1e293b; color: #5eead4; border: 1px solid #475569; }
        body.dark .analysis pre { background: #1e293b; border: 1px solid #475569; }
        body.dark .analysis blockquote { border-left: 4px solid #14b8a6; }
        body.dark .analysis hr { border-top: 2px solid #475569; }
        body.dark .analysis a { color: #5eead4; }
        body.dark .tldr-box { background: #1e293b; border: 2px solid #14b8a6; }
        body.dark .tldr-title { color: #14b8a6; }
        body.dark .beginner-badge { background: #14b8a6; color: #0f172a; }
        body.dark .glossary-section { background: #0f172a; border: 1px solid #475569; }
        
        /* Light Theme */
        body.light {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            color: #1e293b;
            min-height: 100vh;
            transition: background 0.3s ease, color 0.3s ease;
        }
        body.light .header { background: linear-gradient(135deg, #ffffff 0%, #f1f5f9 100%); border: 1px solid #cbd5e1; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.05); }
        body.light .title { color: #0d9488; }
        body.light .subtitle { color: #475569; }
        body.light .status { color: #0d9488; }
        body.light .tab-active { background: #14b8a6; color: #ffffff; box-shadow: 0 4px 12px rgba(20, 184, 166, 0.3); }
        body.light .tab-inactive { background: #ffffff; color: #64748b; border: 1px solid #cbd5e1; }
        body.light .tab-inactive:hover { background: #f8fafc; color: #334155; }
        body.light .card { background: #ffffff; border: 1px solid #cbd5e1; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05); }
        body.light .btn-primary { background: #14b8a6; color: #ffffff; }
        body.light .btn-primary:hover { background: #0d9488; }
        body.light .btn-primary:disabled { background: #cbd5e1; color: #94a3b8; }
        body.light .btn-secondary { background: #f1f5f9; color: #475569; }
        body.light .btn-secondary:hover { background: #e2e8f0; }
        body.light .btn-success { background: #14b8a6; color: #ffffff; }
        body.light .alert { background: #f0fdfa; border-color: #14b8a6; color: #0d9488; }
        body.light .progress-box { background: #f8fafc; border: 1px solid #cbd5e1; }
        body.light .progress-bar { background: #e2e8f0; }
        body.light .progress-fill { background: linear-gradient(90deg, #14b8a6, #5eead4); }
        body.light .smart-box { background: #f0fdfa; border: 2px solid #14b8a6; }
        body.light .input, body.light .textarea { background: #ffffff; border: 1px solid #cbd5e1; color: #1e293b; }
        body.light .input:focus, body.light .textarea:focus { border-color: #14b8a6; box-shadow: 0 0 0 3px rgba(20, 184, 166, 0.1); }
        body.light .api-key-section { background: #f0fdfa; border: 2px solid #14b8a6; }
        body.light .analysis-tab-active { background: #14b8a6; color: #ffffff; }
        body.light .analysis-tab-inactive { background: #ffffff; color: #64748b; border: 1px solid #cbd5e1; }
        body.light .analysis-tab-inactive:hover { background: #f8fafc; color: #334155; }
        body.light .analysis { background: #ffffff; color: #475569; }
        body.light .analysis h1 { color: #0d9488; border-bottom: 2px solid #cbd5e1; }
        body.light .analysis h2 { color: #0f766e; }
        body.light .analysis h3 { color: #14b8a6; }
        body.light .analysis h4 { color: #2dd4bf; }
        body.light .analysis strong { color: #0d9488; }
        body.light .analysis code { background: #f8fafc; color: #0d9488; border: 1px solid #cbd5e1; }
        body.light .analysis pre { background: #f8fafc; border: 1px solid #cbd5e1; }
        body.light .analysis blockquote { border-left: 4px solid #14b8a6; color: #64748b; }
        body.light .analysis hr { border-top: 2px solid #cbd5e1; }
        body.light .analysis a { color: #0d9488; }
        body.light .tldr-box { background: #f0fdfa; border: 2px solid #14b8a6; }
        body.light .tldr-title { color: #0d9488; }
        body.light .beginner-badge { background: #14b8a6; color: #ffffff; }
        body.light .glossary-section { background: #f8fafc; border: 1px solid #cbd5e1; }
        
        /* Common Styles */
        .app { max-width: 1200px; margin: 0 auto; padding: 2rem 1rem; }
        .header { border-radius: 16px; padding: 2.5rem; margin-bottom: 2rem; position: relative; }
        .title { font-size: 2.5rem; font-weight: 700; margin-bottom: 0.5rem; letter-spacing: -0.02em; }
        .subtitle { font-size: 1.125rem; font-weight: 500; }
        .status { font-size: 0.875rem; margin-top: 0.75rem; font-weight: 500; }
        .theme-toggle { position: absolute; top: 2rem; right: 2rem; background: none; border: none; font-size: 1.5rem; cursor: pointer; padding: 0.5rem; border-radius: 50%; transition: all 0.2s; }
        .theme-toggle:hover { transform: scale(1.1); }
        .tabs { display: flex; gap: 0.75rem; margin-bottom: 2rem; flex-wrap: wrap; }
        .tab { padding: 0.875rem 1.75rem; border-radius: 10px; font-weight: 600; cursor: pointer; transition: all 0.2s; border: none; font-size: 1rem; }
        .card { border-radius: 12px; padding: 2rem; }
        .btn { width: 100%; padding: 1rem; border-radius: 10px; font-weight: 600; font-size: 1rem; cursor: pointer; border: none; transition: all 0.2s; margin-top: 0.75rem; }
        .btn-primary:hover { transform: translateY(-1px); }
        .btn:disabled { cursor: not-allowed; }
        .alert { padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem; border-left: 4px solid; }
        .progress-box { border-radius: 8px; padding: 1rem; margin-bottom: 1rem; }
        .progress-bar { width: 100%; height: 8px; border-radius: 4px; overflow: hidden; }
        .progress-fill { height: 100%; transition: width 0.3s; }
        .smart-box { border-radius: 8px; padding: 1rem; margin-bottom: 1.5rem; }
        .input, .textarea { width: 100%; border-radius: 8px; padding: 0.875rem; font-size: 0.95rem; }
        .textarea { font-family: 'Courier New', monospace; resize: vertical; min-height: 250px; }
        .spinner { border: 3px solid rgba(255,255,255,0.2); border-top-color: transparent; border-radius: 50%; width: 1.5rem; height: 1.5rem; animation: spin 0.8s linear infinite; display: inline-block; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .api-key-section { border-radius: 12px; padding: 1.5rem; margin-bottom: 2rem; }
        .analysis-tabs { display: flex; gap: 0.5rem; margin-bottom: 1.5rem; flex-wrap: wrap; padding: 1rem; border-radius: 10px; }
        .analysis-tab { padding: 0.75rem 1.5rem; border-radius: 8px; font-weight: 600; font-size: 0.9rem; cursor: pointer; transition: all 0.2s; border: none; white-space: nowrap; }
        .analysis { border-radius: 12px; padding: 2.5rem; font-size: 0.95rem; line-height: 1.8; font-weight: 400; min-height: 400px; }
        .analysis h1 { display: block; font-size: 1.875rem; margin-top: 0; margin-bottom: 1.25rem; font-weight: 700; letter-spacing: -0.025em; padding-bottom: 0.75rem; }
        .analysis h2 { display: block; font-size: 1.5rem; margin-top: 2rem; margin-bottom: 1.25rem; font-weight: 700; letter-spacing: -0.02em; }
        .analysis h3 { display: block; font-size: 1.25rem; margin-top: 1.75rem; margin-bottom: 1rem; font-weight: 600; }
        .analysis h4 { display: block; font-size: 1.05rem; margin-top: 1.5rem; margin-bottom: 0.75rem; font-weight: 600; }
        .analysis p { display: block; margin-bottom: 1.25rem; line-height: 1.8; }
        .analysis ul, .analysis ol { display: block; margin-left: 1.75rem; margin-bottom: 1.5rem; margin-top: 0.75rem; }
        .analysis li { display: list-item; margin-bottom: 0.75rem; padding-left: 0.5rem; line-height: 1.7; }
        .analysis ul ul, .analysis ol ol, .analysis ul ol, .analysis ol ul { margin-top: 0.5rem; margin-bottom: 0.5rem; margin-left: 1.5rem; }
        .analysis li > p { margin-bottom: 0.5rem; }
        .analysis strong, .analysis b { font-weight: 600; }
        .analysis em, .analysis i { font-style: italic; }
        .analysis code { padding: 0.25rem 0.5rem; border-radius: 4px; font-family: 'Courier New', monospace; font-size: 0.875rem; }
        .analysis pre { display: block; padding: 1.25rem; border-radius: 8px; overflow: auto; margin-bottom: 1.5rem; }
        .analysis pre code { background: none; padding: 0; border: none; }
        .analysis blockquote { display: block; padding-left: 1.25rem; margin-left: 0; margin-bottom: 1.5rem; font-style: italic; }
        .analysis hr { display: block; border: none; margin: 2.5rem 0; }
        .analysis a { text-decoration: underline; }
        .tldr-box { border-radius: 8px; padding: 1.5rem; margin-bottom: 2rem; }
        .tldr-title { font-size: 1.25rem; font-weight: 700; margin-bottom: 1rem; }
        
        /* Beginner Mode Styles */
        .beginner-badge { display: inline-block; padding: 0.5rem 1rem; border-radius: 20px; font-size: 0.875rem; font-weight: 600; margin-bottom: 1rem; }
        .beginner-toggle { display: flex; align-items: center; gap: 1rem; padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem; }
        .toggle-switch { position: relative; display: inline-block; width: 50px; height: 26px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .toggle-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #475569; transition: 0.3s; border-radius: 26px; }
        .toggle-slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 4px; bottom: 4px; background-color: white; transition: 0.3s; border-radius: 50%; }
        input:checked + .toggle-slider { background-color: #14b8a6; }
        input:checked + .toggle-slider:before { transform: translateX(24px); }
        
        /* Glossary Styles */
        .glossary-section { border-radius: 8px; padding: 1.5rem; margin-bottom: 1rem; }
        .glossary-term { font-weight: 600; font-size: 1.1rem; margin-bottom: 0.5rem; margin-top: 1.25rem; }
        .glossary-term:first-of-type { margin-top: 0; }
        .glossary-definition { margin-left: 1rem; line-height: 1.6; }
        .glossary-search { width: 100%; padding: 0.75rem; border-radius: 8px; margin-bottom: 1.5rem; font-size: 0.95rem; }
        
        /* Deck Builder Styles */
        .builder-container { display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; }
        .builder-panel { border-radius: 12px; padding: 1.5rem; min-height: 600px; }
        .builder-search { width: 100%; padding: 0.75rem; border-radius: 8px; margin-bottom: 1rem; font-size: 0.95rem; }
        .builder-filters { display: flex; gap: 1rem; margin-bottom: 1rem; flex-wrap: wrap; }
        .builder-filter-group { display: flex; flex-direction: column; gap: 0.25rem; }
        .builder-filter-label { font-size: 0.8rem; font-weight: 600; opacity: 0.8; }
        .card-browser { max-height: 500px; overflow-y: auto; }
        .card-row { padding: 0.75rem; border-radius: 8px; margin-bottom: 0.5rem; display: flex; justify-content: space-between; align-items: center; cursor: pointer; transition: all 0.2s; }
        .card-row:hover { transform: translateX(4px); }
        .card-info { flex: 1; }
        .card-name { font-weight: 600; font-size: 0.95rem; margin-bottom: 0.25rem; }
        .card-stats { font-size: 0.8rem; opacity: 0.8; }
        .card-add-btn { padding: 0.5rem 1rem; border-radius: 6px; border: none; cursor: pointer; font-weight: 600; transition: all 0.2s; }
        .deck-section { margin-bottom: 1.5rem; }
        .deck-section-title { font-size: 1.1rem; font-weight: 700; margin-bottom: 0.75rem; }
        .deck-card-row { display: flex; justify-content: space-between; align-items: center; padding: 0.5rem; border-radius: 6px; margin-bottom: 0.25rem; }
        .deck-card-name { font-size: 0.9rem; }
        .deck-card-controls { display: flex; gap: 0.5rem; align-items: center; }
        .deck-card-count { font-weight: 600; min-width: 2rem; text-align: center; }
        .deck-btn-small { padding: 0.25rem 0.5rem; border-radius: 4px; border: none; cursor: pointer; font-weight: 600; font-size: 0.85rem; }
        .validation-box { padding: 1rem; border-radius: 8px; margin-bottom: 1rem; }
        .validation-error { margin-bottom: 0.5rem; font-size: 0.85rem; }
        .validation-warning { margin-bottom: 0.5rem; font-size: 0.85rem; opacity: 0.8; }
        .char-selector { margin-bottom: 1.5rem; padding: 1rem; border-radius: 8px; }
        .char-selector-label { font-weight: 600; margin-bottom: 0.5rem; display: block; }
        .range-slider { width: 100%; }
        .template-card { cursor: pointer; transition: all 0.2s; }
        .template-card:hover { transform: translateY(-2px); }
    </style>
</head>
<body class="dark">
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect } = React;
        const GITHUB_BASE = 'https://cdn.jsdelivr.net/gh/JasonBattle510/universus-deck-analyzer@main/UVS_Dataset-main';
        const WORKER_URL = 'https://red-dew-4e75.slothcedric.workers.dev';
        
        marked.setOptions({ breaks: true, gfm: true, headerIds: false, mangle: false });
        
        // Symbol Information Database
        const SYMBOL_INFO = {
            "air": {
                name: "Air",
                emoji: "ðŸ’¨",
                playstyle: "Fast Aggro",
                description: "Focuses on flash attacks, card pool clearing, and readying foundations. Ideal for fast, aggressive strategies.",
                mechanics: [
                    "Flash attacks (play during opponent's turn)",
                    "Card pool clearing",
                    "Foundation readying",
                    "Speed-based pressure"
                ],
                strengths: [
                    "Fast, unpredictable offense",
                    "Resource recycling",
                    "Difficult to defend against"
                ],
                weaknesses: [
                    "Vulnerable to defensive setups",
                    "Requires careful timing"
                ],
                recommendedFor: "Players who like aggressive, reactive gameplay",
                archetypes: ["Aggro", "Tempo", "Flash"]
            },
            "all": {
                name: "All",
                emoji: "ðŸŒŸ",
                playstyle: "Versatile Toolbox",
                description: "A toolbox symbol emphasizing card draw and topdeck manipulation. Offers versatile, mid-range utility.",
                mechanics: [
                    "Card draw engines",
                    "Topdeck manipulation",
                    "Flexible responses",
                    "Utility effects"
                ],
                strengths: [
                    "Adaptable to any matchup",
                    "Consistent card quality",
                    "Strong mid-game"
                ],
                weaknesses: [
                    "Lacks specialized tools",
                    "Can be unfocused"
                ],
                recommendedFor: "Players who want flexibility and consistency",
                archetypes: ["Midrange", "Toolbox", "Goodstuff"]
            },
            "chaos": {
                name: "Chaos",
                emoji: "ðŸŽ²",
                playstyle: "High-Risk Explosive",
                description: "Centers on momentum generation and positive check manipulation, enabling explosive, high-risk plays.",
                mechanics: [
                    "Momentum generation",
                    "Positive check manipulation",
                    "Resource acceleration",
                    "Explosive turns"
                ],
                strengths: [
                    "Massive damage potential",
                    "Momentum advantage",
                    "Game-ending turns"
                ],
                weaknesses: [
                    "High variance",
                    "Vulnerable when behind",
                    "Risk-reward balance"
                ],
                recommendedFor: "Players who embrace variance and big plays",
                archetypes: ["Combo", "Momentum", "All-In"]
            },
            "death": {
                name: "Death",
                emoji: "ðŸ’€",
                playstyle: "Resource Denial Control",
                description: "A control symbol that destroys opponent foundations and burns health, excelling in resource denial.",
                mechanics: [
                    "Foundation destruction",
                    "Direct damage/burn",
                    "Resource denial",
                    "Attrition warfare"
                ],
                strengths: [
                    "Cripples opponent resources",
                    "Multiple win conditions",
                    "Strong late game"
                ],
                weaknesses: [
                    "Slow to establish",
                    "Vulnerable to aggro",
                    "Requires setup time"
                ],
                recommendedFor: "Control players who like denying resources",
                archetypes: ["Control", "Burn", "Attrition"]
            },
            "earth": {
                name: "Earth",
                emoji: "ðŸŒ",
                playstyle: "Big Damage Finisher",
                description: "Specializes in large damage manipulation and foundation flipping, often leading to game-ending attacks.",
                mechanics: [
                    "Damage amplification",
                    "Foundation flipping",
                    "High-power attacks",
                    "Finisher focus"
                ],
                strengths: [
                    "Massive single attacks",
                    "Game-ending potential",
                    "Strong finishers"
                ],
                weaknesses: [
                    "Slow setup",
                    "Telegraphed strategy",
                    "Vulnerable early"
                ],
                recommendedFor: "Players who love big, impactful turns",
                archetypes: ["Ramp", "Big Damage", "Finisher"]
            },
            "evil": {
                name: "Evil",
                emoji: "ðŸ˜ˆ",
                playstyle: "Cost-Based Power",
                description: "Requires costs (like health or discards) for power, enabling negative check manipulation and restrictive effects.",
                mechanics: [
                    "Pay life/discard for effects",
                    "Negative check manipulation",
                    "Restrictive effects",
                    "Powerful payoffs"
                ],
                strengths: [
                    "Powerful effects",
                    "Opponent disruption",
                    "Resource conversion"
                ],
                weaknesses: [
                    "Self-damaging",
                    "Risk of overextension",
                    "Requires careful management"
                ],
                recommendedFor: "Players willing to pay costs for power",
                archetypes: ["Aggressive Control", "Risk-Reward", "Disruption"]
            },
            "fire": {
                name: "Fire",
                emoji: "ðŸ”¥",
                playstyle: "Premier Aggro",
                description: "The premier aggressive symbol, using self-mill and stat pumps to burst through opponents quickly.",
                mechanics: [
                    "Self-mill acceleration",
                    "Stat pumps (+damage/speed)",
                    "Fast damage output",
                    "Aggressive curve"
                ],
                strengths: [
                    "Fastest clock in game",
                    "High pressure",
                    "Punishes slow decks"
                ],
                weaknesses: [
                    "Runs out of gas",
                    "Vulnerable to blocks",
                    "Weak late game"
                ],
                recommendedFor: "Aggressive players who want fast wins",
                archetypes: ["Aggro", "Rush", "Burn"]
            },
            "good": {
                name: "Good",
                emoji: "âœ¨",
                playstyle: "Defensive Wall",
                description: "Highly defensive, focused on quick foundation building and block modifiers, excelling in mid-game walling.",
                mechanics: [
                    "Fast foundation building",
                    "High block modifiers",
                    "Defensive positioning",
                    "Mid-game strength"
                ],
                strengths: [
                    "Superior blocking",
                    "Resource advantage",
                    "Survives aggro"
                ],
                weaknesses: [
                    "Slow win condition",
                    "Can struggle to close",
                    "Vulnerable to control"
                ],
                recommendedFor: "Defensive players who like outlasting opponents",
                archetypes: ["Defense", "Midrange", "Wall"]
            },
            "life": {
                name: "Life",
                emoji: "â¤ï¸",
                playstyle: "Mid-Range Grower",
                description: "A mid-range symbol that gains health and manipulates progressive difficulty, building toward impactful turns.",
                mechanics: [
                    "Health gain",
                    "Progressive difficulty manipulation",
                    "Board building",
                    "Scaling threats"
                ],
                strengths: [
                    "Life buffer vs aggro",
                    "Grows over time",
                    "Strong turns 5-7"
                ],
                weaknesses: [
                    "Vulnerable early",
                    "Requires setup",
                    "Can be too slow"
                ],
                recommendedFor: "Midrange players who like building advantages",
                archetypes: ["Midrange", "Life Gain", "Progressive"]
            },
            "order": {
                name: "Order",
                emoji: "âš–ï¸",
                playstyle: "Lock Control",
                description: "A control symbol that commits opponent resources and freezes cards in place, disrupting plans.",
                mechanics: [
                    "Commit opponent cards",
                    "Freeze effects",
                    "Resource lock",
                    "Tempo disruption"
                ],
                strengths: [
                    "Locks opponent out",
                    "Disrupts game plans",
                    "Strong control tools"
                ],
                weaknesses: [
                    "Slow to establish",
                    "Vulnerable to aggro",
                    "Requires precision"
                ],
                recommendedFor: "Control players who like lockout strategies",
                archetypes: ["Control", "Lock", "Prison"]
            },
            "void": {
                name: "Void",
                emoji: "ðŸŒŒ",
                playstyle: "Proactive Control",
                description: "A proactive control symbol that discards opponent hands and negates abilities, shutting down threats.",
                mechanics: [
                    "Hand disruption",
                    "Ability negation",
                    "Proactive control",
                    "Threat shutdown"
                ],
                strengths: [
                    "Shuts down combos",
                    "Hand control",
                    "Preemptive disruption"
                ],
                weaknesses: [
                    "Timing-dependent",
                    "Can struggle vs aggro",
                    "Requires knowledge"
                ],
                recommendedFor: "Control players who like disrupting strategies",
                archetypes: ["Discard", "Control", "Disruption"]
            },
            "water": {
                name: "Water",
                emoji: "ðŸ’§",
                playstyle: "Defensive Adaptation",
                description: "A defensive symbol that clogs card pools and refreshes the block zone, adaptable for both defense and setup.",
                mechanics: [
                    "Card pool clogging",
                    "Block zone refresh",
                    "Defensive tools",
                    "Setup enablers"
                ],
                strengths: [
                    "Defensive versatility",
                    "Slows opponent",
                    "Adaptable strategy"
                ],
                weaknesses: [
                    "Lacks explosive power",
                    "Can be reactive",
                    "Moderate clock"
                ],
                recommendedFor: "Players who like flexible, defensive gameplay",
                archetypes: ["Control", "Tempo", "Defensive"]
            },
            "infinity": {
                name: "Universal",
                emoji: "âˆž",
                playstyle: "Universal Neutral",
                description: "Neutral symbol cards that can be included in any deck, providing flexible utility options.",
                mechanics: [
                    "Universal playability",
                    "Flexible effects",
                    "Staple cards"
                ],
                strengths: [
                    "Works in any deck",
                    "Versatile options"
                ],
                weaknesses: [
                    "Often less powerful",
                    "Generic effects"
                ],
                recommendedFor: "All players as deck staples",
                archetypes: ["Any"]
            }
        };
        
        // Deck Templates (Starter decks for each symbol)
        const DECK_TEMPLATES = {
            "fire_aggro": {
                name: "Fire Rush (Starter)",
                symbol: "fire",
                description: "Fast, aggressive Fire deck focused on dealing 31 damage by turn 4-5.",
                cardList: [
                    // This is a template structure - actual cards depend on loaded sets
                    { name: "Character", type: "Character", symbol: "fire", count: 1 },
                    { name: "Foundation", type: "Foundation", symbol: "fire", count: 25 },
                    { name: "Low Cost Attack", type: "Attack", difficulty: 2, count: 8 },
                    { name: "Medium Attack", type: "Attack", difficulty: 4, count: 12 },
                    { name: "Finisher", type: "Attack", difficulty: 6, count: 4 }
                ],
                strategy: "Play aggressively from turn 2. Maximize damage output. Win by turn 5."
            },
            "water_control": {
                name: "Water Defense (Starter)",
                symbol: "water",
                description: "Defensive Water deck that survives early aggression and wins late.",
                strategy: "Block aggressively turns 2-4. Stabilize turn 5. Win turns 6-8."
            },
            "air_tempo": {
                name: "Air Flash (Starter)", 
                symbol: "air",
                description: "Fast Air deck using flash attacks and foundation manipulation.",
                strategy: "Use flash attacks for surprise pressure. Ready foundations for multiple threats."
            },
            "earth_ramp": {
                name: "Earth Big Damage (Starter)",
                symbol: "earth",
                description: "Ramp into massive damage attacks that end the game in one hit.",
                strategy: "Build foundations turns 1-4. Drop huge attacks turns 5-6."
            },
            "death_control": {
                name: "Death Denial (Starter)",
                symbol: "death",
                description: "Control deck that destroys opponent resources and burns life total.",
                strategy: "Destroy foundations early. Burn + control to win late."
            },
            "chaos_momentum": {
                name: "Chaos Explosive (Starter)",
                symbol: "chaos",
                description: "High-variance deck that generates momentum for explosive turns.",
                strategy: "Build momentum. Execute game-ending turn 5-6."
            }
        };
        
        // Glossary Database
        const GLOSSARY = {
            "Ally": "A card type that works together with other Ally cards. Many Ally cards have effects that trigger when other Allies are in play or in your card pool.",
            "Blitz": "A triggered ability that activates automatically when you play this card. You don't choose - it just happens!",
            "Block": "A defensive action where you use a foundation card to reduce incoming damage. The foundation's block modifier is added to your flip.",
            "Block Modifier": "The bonus you add to your control check when blocking. Shows as a number with a zone (e.g., High +2 means +2 when blocking high attacks).",
            "Block Zone": "Which attack zone this foundation can block. High, Mid, or Low.",
            "Card Pool": "The area where played attacks and actions go after resolving. Cards stay here until end of turn or removed by effects.",
            "Character": "Your main card that represents you in the game. It determines your hand size, vitality, and special abilities.",
            "Check": "See Control Check.",
            "Commit": "To turn a foundation face-down to pay for a card effect or ability.",
            "Control": "The number on a foundation card used to pay for other cards. Higher control = easier to play expensive cards.",
            "Control Check": "When playing a card, you flip cards from your deck until the total control equals or exceeds the difficulty.",
            "Damage": "How much health the opponent loses when an attack hits. Can be modified by various effects.",
            "Difficulty": "The cost to play a card. You must flip cards totaling this much control or higher from your deck.",
            "Discard": "The pile where cards go when discarded from hand or destroyed from staging. Face-up and publicly visible.",
            "Enhance": "An optional effect you can activate by flipping (or sometimes committing) a foundation. The foundation must say Enhance.",
            "Face-down": "A card turned face-down in your staging area. It provides no effects but can't be destroyed by most removal.",
            "Face-up": "A card played normally. Foundations are typically played face-up to provide control checks.",
            "Foundation": "Cards you play into your staging area to generate control checks. They also have block modifiers and some have abilities.",
            "Hand Size": "The maximum number of cards you draw at the start of each turn. Shown on your character card.",
            "Keyword": "A special trait on a card that may interact with other cards or abilities (e.g., Weapon, Unique, Pirate).",
            "Main Phase": "The phase where you play foundations and attacks. Occurs after drawing and before the end phase.",
            "Momentum": "A special resource gained from landing successful attacks or certain effects. Used to pay for powerful abilities.",
            "Powerful": "A keyword that adds bonus damage when the attack deals damage. Powerful:2 means +2 damage.",
            "Progressive Difficulty": "Each additional copy of this card you play in a turn costs more. Usually increases by 2 per copy.",
            "Ready": "To flip a foundation face-up (if it was face-down) so it can be used for control checks and blocking.",
            "Response": "An ability that triggers when a specific condition is met. Usually says 'Response:' before the effect.",
            "Slam": "When this attack deals damage, the opponent discards a card from their hand (if they have any).",
            "Speed": "How fast an attack is. Higher speed attacks are harder to block and resolve first in attack vs attack scenarios.",
            "Staging Area": "Where you play your foundation cards. Can have up to 30 foundations.",
            "Static": "An ability that is always active as long as the card is in play. Usually modifies game rules or deck construction.",
            "Tenacious": "A keyword that makes the foundation harder to destroy or discard.",
            "Unique": "You can only have one copy of Unique cards with the same name in play at a time.",
            "Vitality": "Your character's health. When it reaches 0, you lose the game.",
            "Weapon": "A keyword trait. Some cards care about Weapons and have special interactions with them.",
            "Zone": "The attack zone - High, Mid, or Low. You must block with a foundation that matches the attack's zone."
        };
        
        function App() {
            const [activeTab, setActiveTab] = useState('analyze');
            const [decks, setDecks] = useState([]);
            const [selectedDeck, setSelectedDeck] = useState(null);
            const [deckInput, setDeckInput] = useState('');
            const [deckName, setDeckName] = useState('');
            const [isAnalyzing, setIsAnalyzing] = useState(false);
            const [error, setError] = useState('');
            const [cardDatabase, setCardDatabase] = useState({});
            const [loadedSets, setLoadedSets] = useState([]);
            const [isLoadingSets, setIsLoadingSets] = useState(false);
            const [availableSets, setAvailableSets] = useState([]);
            const [selectedSets, setSelectedSets] = useState([]);
            const [suggestedSets, setSuggestedSets] = useState([]);
            const [isDetecting, setIsDetecting] = useState(false);
            const [detectProgress, setDetectProgress] = useState({ current: 0, total: 0 });
            const [apiKey, setApiKey] = useState('');
            const [apiKeyInput, setApiKeyInput] = useState('');
            const [activeAnalysisTab, setActiveAnalysisTab] = useState(0);
            const [theme, setTheme] = useState('dark');
            const [beginnerMode, setBeginnerMode] = useState(false);
            const [glossarySearch, setGlossarySearch] = useState('');
            const [deckCards, setDeckCards] = useState([]);
            
            // Deck Builder state
            const [builderDeck, setBuilderDeck] = useState({
                name: 'Untitled Deck',
                character: null,
                cards: []
            });
            const [builderSearch, setBuilderSearch] = useState('');
            const [builderFilters, setBuilderFilters] = useState({
                types: ['Attack', 'Foundation', 'Action'],
                diffMin: 0,
                diffMax: 10,
                showAllSymbols: false,
                activeSymbolTab: 'all'
            });
            
            useEffect(() => {
                const stored = localStorage.getItem('universus-decks-v3');
                if (stored) {
                    try {
                        const data = JSON.parse(stored);
                        setDecks(data.decks || []);
                        setLoadedSets(data.loadedSets || []);
                    } catch (e) { console.error(e); }
                }
                const storedKey = localStorage.getItem('anthropic-api-key');
                if (storedKey) {
                    setApiKey(storedKey);
                    setApiKeyInput(storedKey);
                }
                const storedTheme = localStorage.getItem('theme') || 'dark';
                setTheme(storedTheme);
                document.body.className = storedTheme;
                
                const storedBeginnerMode = localStorage.getItem('beginner-mode') === 'true';
                setBeginnerMode(storedBeginnerMode);
                
                loadSetList();
            }, []);
            
            useEffect(() => {
                if (decks.length > 0) {
                    const lightDecks = decks.map(d => ({ id: d.id, name: d.name, deckList: d.deckList, analysis: d.analysis, cards: d.cards, createdAt: d.createdAt }));
                    localStorage.setItem('universus-decks-v3', JSON.stringify({ decks: lightDecks, loadedSets }));
                }
            }, [decks, loadedSets]);
            
            useEffect(() => {
                localStorage.setItem('beginner-mode', beginnerMode);
            }, [beginnerMode]);
            
            useEffect(() => {
                if (selectedDeck?.cards) {
                    setDeckCards(selectedDeck.cards);
                }
            }, [selectedDeck]);
            
            const toggleTheme = () => {
                const newTheme = theme === 'dark' ? 'light' : 'dark';
                setTheme(newTheme);
                document.body.className = newTheme;
                localStorage.setItem('theme', newTheme);
            };
            
            const saveApiKey = () => {
                localStorage.setItem('anthropic-api-key', apiKeyInput);
                setApiKey(apiKeyInput);
                alert('API key saved!');
            };
            
            const clearApiKey = () => {
                if (confirm('Remove your API key?')) {
                    localStorage.removeItem('anthropic-api-key');
                    setApiKey('');
                    setApiKeyInput('');
                }
            };
            
            const loadSetList = async () => {
                try {
                    const response = await fetch(`${GITHUB_BASE}/setList.json`);
                    if (response.ok) {
                        const data = await response.json();
                        setAvailableSets(data.sets || []);
                        setSelectedSets(data.sets?.map(s => s.id) || []);
                    }
                } catch (e) { console.error(e); }
            };
            
            const detectNeededSets = async () => {
                if (!deckInput.trim()) { setError('Enter deck list first'); return; }
                setIsDetecting(true);
                setSuggestedSets([]);
                setDetectProgress({ current: 0, total: availableSets.length });
                
                const cardNames = deckInput.split('\n').map(line => line.trim()).filter(line => line && !line.startsWith('[')).map(line => {
                    const match = line.match(/^\d+\s+(.+)$/);
                    return match ? match[1].trim().toLowerCase() : '';
                }).filter(Boolean);
                
                const neededSets = new Set();
                for (let i = 0; i < availableSets.length; i++) {
                    const set = availableSets[i];
                    setDetectProgress({ current: i + 1, total: availableSets.length });
                    try {
                        const response = await fetch(`${GITHUB_BASE}/${set.id}/setData.json`);
                        if (!response.ok) continue;
                        const data = await response.json();
                        const setCardNames = Object.values(data.Cards).map(card => card.Name.toLowerCase());
                        if (cardNames.some(name => setCardNames.includes(name))) neededSets.add(set.id);
                    } catch (err) { console.error(`Failed: ${set.id}`, err); }
                }
                setSuggestedSets(Array.from(neededSets));
                setSelectedSets(Array.from(neededSets));
                setIsDetecting(false);
                setDetectProgress({ current: 0, total: 0 });
            };
            
            const loadSets = async () => {
                setIsLoadingSets(true);
                setError('');
                const newDatabase = {};
                const successful = [];
                for (const setId of selectedSets) {
                    try {
                        const url = `${GITHUB_BASE}/${setId}/setData.json`;
                        const response = await fetch(url);
                        if (!response.ok) continue;
                        const data = await response.json();
                        Object.values(data.Cards).forEach(card => {
                            const key = card.Name.toLowerCase().trim();
                            if (!newDatabase[key]) newDatabase[key] = [];
                            newDatabase[key].push({ ...card, setId });
                        });
                        successful.push(setId);
                    } catch (err) { console.error(`Failed: ${setId}`, err); }
                }
                setCardDatabase(newDatabase);
                setLoadedSets(successful);
                setIsLoadingSets(false);
                if (successful.length === 0) setError('Failed to load sets.');
            };
            
            const generateAIAnalysis = async (cards, isBeginnerMode) => {
                if (!apiKey) return 'âš ï¸ **AI Analysis Unavailable**\n\nPlease add your Anthropic API key in Settings.\n\nGet your key at: https://console.anthropic.com/';
                
                try {
                    const cardDetails = cards.map(c => {
                        if (!c.card) return `${c.count}x ${c.name} (NOT FOUND)`;
                        let detail = `${c.count}x ${c.card.Name} (${c.card.Cardtype})`;
                        if (c.card.Difficulty != null) detail += ` - Diff: ${c.card.Difficulty}, Control: ${c.card.Check}`;
                        if (c.card.Speed != null) detail += ` - Speed: ${c.card.Speed}, Damage: ${c.card.Damage}, Zone: ${c.card.AttackZone}`;
                        if (c.card.BlockZone) detail += ` - Block: ${c.card.BlockZone}+${c.card.BlockMod}`;
                        if (c.card.Keywords?.length) detail += ` - Keywords: ${c.card.Keywords.map(k => k.Name).join(', ')}`;
                        if (c.card.Abilities?.length) {
                            detail += `\n  Abilities:`;
                            c.card.Abilities.forEach(a => detail += `\n  - ${a.Type}${a.Cost ? ` (${a.Cost})` : ''}: ${a.Effect}`);
                        }
                        return detail;
                    }).join('\n\n');

                    const character = cards.find(c => c.card?.Cardtype === 'Character');
                    let charDetails = '';
                    if (character?.card) {
                        const c = character.card;
                        charDetails = `Character: ${c.Name}\nHand Size: ${c.HandSize}, Vitality: ${c.Health}\n`;
                        if (c.Abilities?.length) {
                            charDetails += 'Character Abilities:\n';
                            c.Abilities.forEach(a => charDetails += `- ${a.Type}: ${a.Effect}\n`);
                        }
                    }

                    const prompt = isBeginnerMode 
                        ? `You are teaching Universus TCG to a COMPLETE BEGINNER. This is their first time analyzing a deck.

${charDetails}

FULL DECK LIST:
${cardDetails}

CRITICAL: Assume the opponent starts at 31 vitality (standard). When explaining damage, show how the deck reaches 31+ total damage to win. Use simple math like "Card A does 5 damage + Card B does 8 damage = 13 total."

Provide analysis using SIMPLE LANGUAGE with inline explanations and these exact sections (use ## for headers):

## Overview
Explain what this deck does in 3-4 sentences. What's the main strategy? Is it aggressive (wins fast), defensive (wins late), or something else? How does it win?

## Win Condition
How does this deck win? Explain the damage route simply. Show the math of how you get to 31 damage (the opponent's starting health):
- Example: "Turns 3-4: Play Card A four times (5 damage each) = 20 damage. Turn 5: Play Card B (8 damage) = 28 total. Turn 6: Play Card C (5 damage) = 33 total. You win!"

When you mention a game term (like "Blitz", "Enhance", "Control Check", "Foundation", "Momentum"), add a brief inline definition in parentheses. Use actual card names and show the math.

## Key Cards
List the 5 most important cards and explain WHY they're important in simple terms. Define any game terms inline.

## How to Play (Turn-by-Turn)
Break down the first 5 turns step-by-step. Define game terms inline as you use them:
- **Turns 1-2:** What to do (be specific - which cards to play)
- **Turns 3-4:** What to do (be specific - how to start dealing damage)
- **Turn 5+:** How to finish the game and reach 31 damage

## Common Mistakes
What do new players often do wrong with this deck? Give 3-4 specific mistakes to avoid.

## Tips for Success
3-4 helpful tips for playing this deck well.

IMPORTANT: When you use game terms like "Blitz", "Enhance", "Foundation", "Control Check", "Momentum", "Card Pool", etc., add a brief inline explanation in parentheses right after. For example: "Use the Blitz ability (which triggers automatically when you play the card) to ready 2 foundations (cards that provide resources)."

Use simple language. Be encouraging and helpful!`
                        : `You are an expert Universus TCG deck analyst. Analyze this deck and provide a DETAILED strategic breakdown.

${charDetails}

FULL DECK LIST:
${cardDetails}

CRITICAL: Assume the opponent starts at 31 vitality (standard). All damage calculations must show how the deck reaches 31+ total damage. Break down damage by turn ranges and show the math.

Provide comprehensive analysis with these exact sections (use ## for headers):

## Overview
Write a strategic overview (120-150 words) covering:
- Deck archetype (aggro/midrange/control/combo)
- Core game plan and how it wins
- Game phases broken down by turns (e.g., turns 1-2: setup, turns 3-4: pressure, turns 5-6: finish)
- Damage path to 31 vitality with specific numbers
- Expected win turn range
- Matchup positioning (strong vs / weak vs)

## Win Condition
Explain the primary kill route with EXACT damage calculations that total 31+ vitality. Break down by turn ranges:
- Turns X-Y: [cards] = Z damage
- Turns A-B: [cards] = C damage
- Total: 31+ damage for the win

Include secondary win conditions if applicable.

## Key Combos
Important card interactions and synergies. Be specific with card names and exact sequencing.

## Gameplay Strategy
Turn-by-turn gameplay and ideal sequences. What does this deck do each turn to reach the win condition?

## Core Engine
Essential cards and how they work together. What cards must be in play for the deck to function?

## Strengths
What this deck does well. Why would you play this deck?

## Weaknesses
Vulnerabilities and difficult matchups. What beats this deck?

## Matchup Strategy
Provide specific game plans against different archetypes:

**vs Aggro Decks (trying to win turn 3-5):**
- Are you faster or slower than aggro?
- If faster: Race strategy (maximize damage, skip defense)
- If slower: Survival strategy (which attacks to block, what turn to stabilize by)

**vs Midrange Decks (balanced, win turn 5-7):**
- Are you the beatdown or control?
- Key turn ranges for pressure/defense
- Resource management strategy

**vs Control Decks (win late, turn 8+):**
- Apply pressure or go late?
- Key disruption targets
- Win window before they take over

For each matchup, be specific: "Block their turn 3 high-speed attacks" not just "play defensively."

Be specific with card names, exact numbers, damage calculations to 31 vitality, and gameplay sequences.`;

                    const response = await fetch(WORKER_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'x-api-key': apiKey },
                        body: JSON.stringify({
                            model: 'claude-sonnet-4-20250514',
                            max_tokens: 2000,
                            messages: [{ role: 'user', content: prompt }]
                        })
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || `HTTP ${response.status}`);
                    }
                    
                    const data = await response.json();
                    return data.content?.find(c => c.type === 'text')?.text || 'Analysis failed';
                } catch (err) {
                    console.error('AI failed:', err);
                    return `âš ï¸ **AI Analysis Failed**\n\nError: ${err.message}\n\nCheck your API key in Settings.`;
                }
            };
            
            const analyzeDeck = async () => {
                if (!deckInput.trim() || !deckName.trim()) { setError('Enter deck name and list'); return; }
                if (Object.keys(cardDatabase).length === 0) { setError('Load sets first!'); return; }
                setIsAnalyzing(true);
                setError('');
                try {
                    const cards = deckInput.split('\n').map(line => line.trim()).filter(line => line && !line.startsWith('[')).map(line => {
                        const match = line.match(/^(\d+)\s+(.+)$/);
                        if (match) {
                            const count = parseInt(match[1]);
                            const cardName = match[2].trim();
                            const cardVersions = cardDatabase[cardName.toLowerCase()];
                            return { count, card: cardVersions?.[0], name: cardName };
                        }
                        return null;
                    }).filter(Boolean);
                    
                    const aiAnalysis = await generateAIAnalysis(cards, beginnerMode);
                    setDecks([...decks, { 
                        id: Date.now(), 
                        name: deckName, 
                        deckList: deckInput, 
                        analysis: aiAnalysis, 
                        cards: cards,
                        createdAt: new Date().toISOString() 
                    }]);
                    setDeckInput('');
                    setDeckName('');
                    setSuggestedSets([]);
                    setActiveTab('library');
                } catch (err) {
                    setError('Analysis failed: ' + err.message);
                } finally {
                    setIsAnalyzing(false);
                }
            };
            

            
            
            // Deck Builder Functions
            const addCardToBuilder = (card) => {
                const existing = builderDeck.cards.find(c => c.card.Name === card.Name);
                if (existing) {
                    if (existing.count < 4) {
                        setBuilderDeck({
                            ...builderDeck,
                            cards: builderDeck.cards.map(c => 
                                c.card.Name === card.Name ? { ...c, count: c.count + 1 } : c
                            )
                        });
                    }
                } else {
                    setBuilderDeck({
                        ...builderDeck,
                        cards: [...builderDeck.cards, { card, count: 1 }]
                    });
                }
            };
            
            const removeCardFromBuilder = (card) => {
                const existing = builderDeck.cards.find(c => c.card.Name === card.Name);
                if (existing) {
                    if (existing.count > 1) {
                        setBuilderDeck({
                            ...builderDeck,
                            cards: builderDeck.cards.map(c =>
                                c.card.Name === card.Name ? { ...c, count: c.count - 1 } : c
                            )
                        });
                    } else {
                        setBuilderDeck({
                            ...builderDeck,
                            cards: builderDeck.cards.filter(c => c.card.Name !== card.Name)
                        });
                    }
                }
            };
            
            const setBuilderCharacter = (card) => {
                setBuilderDeck({ ...builderDeck, character: card });
            };
            
            const validateBuilderDeck = () => {
                const errors = [];
                const warnings = [];
                
                const totalCards = builderDeck.cards.reduce((sum, c) => sum + c.count, 0) + (builderDeck.character ? 1 : 0);
                
                if (!builderDeck.character) errors.push('No character selected');
                if (totalCards !== 60) errors.push(`Deck has ${totalCards} cards (need exactly 60)`);
                
                builderDeck.cards.forEach(entry => {
                    if (entry.count > 4) errors.push(`${entry.card.Name}: ${entry.count} copies (max 4)`);
                });
                
                const foundationCount = builderDeck.cards
                    .filter(c => c.card.Cardtype === 'Foundation')
                    .reduce((sum, c) => sum + c.count, 0);
                
                if (foundationCount < 25) warnings.push(`Only ${foundationCount} foundations (recommend 28-30)`);
                if (foundationCount > 35) warnings.push(`${foundationCount} foundations (recommend 28-30)`);
                
                return { errors, warnings, isValid: errors.length === 0 };
            };
            
            const exportBuilderDeck = () => {
                let text = '';
                if (builderDeck.character) {
                    text += `[Character]\n1 ${builderDeck.character.Name}\n\n`;
                }
                
                const foundations = builderDeck.cards.filter(c => c.card.Cardtype === 'Foundation');
                const attacks = builderDeck.cards.filter(c => c.card.Cardtype === 'Attack');
                const actions = builderDeck.cards.filter(c => c.card.Cardtype === 'Action');
                
                if (foundations.length > 0) {
                    text += '[Foundations]\n';
                    foundations.forEach(e => text += `${e.count} ${e.card.Name}\n`);
                    text += '\n';
                }
                
                if (attacks.length > 0) {
                    text += '[Attacks]\n';
                    attacks.forEach(e => text += `${e.count} ${e.card.Name}\n`);
                    text += '\n';
                }
                
                if (actions.length > 0) {
                    text += '[Actions]\n';
                    actions.forEach(e => text += `${e.count} ${e.card.Name}\n`);
                }
                
                return text;
            };
            
            const analyzeBuilderDeck = async () => {
                const validation = validateBuilderDeck();
                if (!validation.isValid) {
                    setError(validation.errors.join(', '));
                    return;
                }
                
                const deckText = exportBuilderDeck();
                setDeckInput(deckText);
                setDeckName(builderDeck.name);
                setActiveTab('analyze');
                
                // Auto-trigger analysis
                setTimeout(() => analyzeDeck(), 100);
            };
            
            const saveBuilderDeck = () => {
                const validation = validateBuilderDeck();
                if (!validation.isValid) {
                    alert('Please fix deck errors before saving:\n' + validation.errors.join('\n'));
                    return;
                }
                
                const deckText = exportBuilderDeck();
                const newDeck = {
                    id: Date.now(),
                    name: builderDeck.name,
                    deckList: deckText,
                    cards: builderDeck.cards,
                    analysis: '',
                    createdAt: new Date().toISOString()
                };
                
                setDecks([...decks, newDeck]);
                alert('Deck saved to library!');
            };
            
            const clearBuilderDeck = () => {
                if (confirm('Clear current deck?')) {
                    setBuilderDeck({
                        name: 'Untitled Deck',
                        character: null,
                        cards: []
                    });
                }
            };
            
            const debugCardStructure = () => {
                const allCards = Object.values(cardDatabase).flat();
                if (allCards.length === 0) {
                    alert('No cards loaded! Load sets first in Settings.');
                    return;
                }
                
                const sampleCard = allCards[0];
                const sampleCharacter = allCards.find(c => c.Cardtype === 'Character') || sampleCard;
                
                console.log('=== SAMPLE CARD ===');
                console.log(sampleCard);
                console.log('\n=== SAMPLE CHARACTER ===');
                console.log(sampleCharacter);
                console.log('\n=== ALL FIELDS ON SAMPLE CARD ===');
                console.log(Object.keys(sampleCard));
                
                alert('Card structure logged to console! Press F12 to view.\n\nLook for fields like: Symbol, Resource, Element, Faction, etc.');
            };
            
            const calculateDeckStats = () => {
                const totalCards = builderDeck.cards.reduce((s, c) => s + c.count, 0) + (builderDeck.character ? 1 : 0);
                const foundations = builderDeck.cards.filter(c => c.card.Cardtype === 'Foundation');
                const attacks = builderDeck.cards.filter(c => c.card.Cardtype === 'Attack');
                const actions = builderDeck.cards.filter(c => c.card.Cardtype === 'Action');
                
                const foundationCount = foundations.reduce((s, c) => s + c.count, 0);
                const attackCount = attacks.reduce((s, c) => s + c.count, 0);
                const actionCount = actions.reduce((s, c) => s + c.count, 0);
                
                // Calculate difficulty distribution
                const distribution = { '0-2': 0, '3-4': 0, '5-6': 0, '7-8': 0, '9+': 0 };
                builderDeck.cards.forEach(entry => {
                    const diff = entry.card.Difficulty || 0;
                    const count = entry.count;
                    if (diff <= 2) distribution['0-2'] += count;
                    else if (diff <= 4) distribution['3-4'] += count;
                    else if (diff <= 6) distribution['5-6'] += count;
                    else if (diff <= 8) distribution['7-8'] += count;
                    else distribution['9+'] += count;
                });
                
                // Calculate average difficulty (non-foundations)
                const nonFoundations = [...attacks, ...actions];
                const totalDiff = nonFoundations.reduce((sum, entry) => {
                    return sum + (entry.card.Difficulty || 0) * entry.count;
                }, 0);
                const avgDiff = nonFoundations.length > 0 ? (totalDiff / (attackCount + actionCount)).toFixed(1) : 0;
                
                // Determine curve speed
                let curveSpeed = 'MIDRANGE';
                if (distribution['0-2'] + distribution['3-4'] > (totalCards - foundationCount) * 0.7) {
                    curveSpeed = 'AGGRO';
                } else if (distribution['7-8'] + distribution['9+'] > (totalCards - foundationCount) * 0.4) {
                    curveSpeed = 'CONTROL';
                }
                
                // Symbol distribution
                const symbolCounts = {};
                builderDeck.cards.forEach(entry => {
                    const symbols = entry.card.Symbols || [];
                    symbols.forEach(sym => {
                        const key = sym.toLowerCase();
                        symbolCounts[key] = (symbolCounts[key] || 0) + entry.count;
                    });
                });
                
                return {
                    totalCards,
                    foundationCount,
                    attackCount,
                    actionCount,
                    distribution,
                    avgDiff,
                    curveSpeed,
                    symbolCounts
                };
            };
            
            const getDeckSynergyHints = () => {
                if (builderDeck.cards.length === 0) return [];
                
                const stats = calculateDeckStats();
                const hints = [];
                const characterSymbols = builderDeck.character?.Symbols || [];
                
                // Foundation count hints
                if (stats.foundationCount < 25) {
                    hints.push({ type: 'warning', text: `Only ${stats.foundationCount} foundations - add ${25 - stats.foundationCount}+ more for consistency` });
                } else if (stats.foundationCount > 35) {
                    hints.push({ type: 'warning', text: `${stats.foundationCount} foundations is very high - consider more attacks/actions` });
                }
                
                // Curve hints
                if (stats.curveSpeed === 'AGGRO' && stats.foundationCount > 30) {
                    hints.push({ type: 'info', text: 'âš¡ Aggro deck with many foundations - consider cutting to 25-28 for faster draws' });
                } else if (stats.curveSpeed === 'CONTROL' && stats.foundationCount < 30) {
                    hints.push({ type: 'info', text: 'ðŸ›¡ï¸ Control deck wants 30-32 foundations for consistency' });
                }
                
                // Symbol focus hints
                if (characterSymbols.length > 0 && Object.keys(stats.symbolCounts).length > 0) {
                    const totalNonFoundation = stats.totalCards - stats.foundationCount - 1;
                    const charSymbolCounts = characterSymbols.reduce((sum, sym) => {
                        return sum + (stats.symbolCounts[sym.toLowerCase()] || 0);
                    }, 0);
                    const focusPercentage = (charSymbolCounts / totalNonFoundation) * 100;
                    
                    if (focusPercentage < 70 && characterSymbols.length === 1) {
                        hints.push({ type: 'warning', text: `Only ${focusPercentage.toFixed(0)}% ${characterSymbols[0]} cards - add more for better synergy` });
                    } else if (focusPercentage > 90) {
                        hints.push({ type: 'success', text: `âœ… Strong ${characterSymbols.join('/')} focus (${focusPercentage.toFixed(0)}%)` });
                    }
                }
                
                // Specific symbol strategy hints
                if (characterSymbols.includes('fire') || characterSymbols.includes('Fire')) {
                    if (stats.curveSpeed !== 'AGGRO') {
                        hints.push({ type: 'info', text: 'ðŸ”¥ Fire works best with aggressive curves (Diff 2-5)' });
                    }
                    if (stats.avgDiff > 5) {
                        hints.push({ type: 'warning', text: 'ðŸ”¥ Fire average difficulty is high - lower curve for faster wins' });
                    }
                }
                
                if (characterSymbols.includes('water') || characterSymbols.includes('Water')) {
                    if (stats.foundationCount < 28) {
                        hints.push({ type: 'info', text: 'ðŸ’§ Water decks benefit from 28-30 foundations for defense' });
                    }
                }
                
                if (characterSymbols.includes('earth') || characterSymbols.includes('Earth')) {
                    const highCostCards = stats.distribution['7-8'] + stats.distribution['9+'];
                    if (highCostCards < 4) {
                        hints.push({ type: 'info', text: 'ðŸŒ Earth decks want 4-6 high-cost finishers (Diff 7+)' });
                    }
                }
                
                // Attack/foundation balance
                const attackRatio = stats.attackCount / stats.totalCards;
                if (attackRatio < 0.3) {
                    hints.push({ type: 'warning', text: 'Low attack count - add more threats to pressure opponent' });
                } else if (attackRatio > 0.6) {
                    hints.push({ type: 'warning', text: 'Very attack-heavy - may struggle with control checks' });
                }
                
                return hints;
            };
            
            const parseAnalysis = (analysis) => {
                const sections = [];
                const lines = analysis.split('\n');
                let currentSection = { title: 'Overview', content: '' };
                
                for (let line of lines) {
                    if (line.startsWith('## ')) {
                        if (currentSection.content.trim()) sections.push(currentSection);
                        currentSection = { title: line.replace('## ', '').trim(), content: '' };
                    } else {
                        currentSection.content += line + '\n';
                    }
                }
                
                if (currentSection.content.trim()) sections.push(currentSection);
                
                // Add Glossary tab for beginner mode only
                if (beginnerMode) {
                    sections.push({
                        title: 'ðŸ“– Glossary',
                        content: '<div id="glossary-content"></div>'
                    });
                }
                
                return sections.length > 0 ? sections : [{ title: 'Analysis', content: analysis }];
            };
            
            const filteredGlossary = Object.keys(GLOSSARY)
                .filter(term => 
                    glossarySearch === '' || 
                    term.toLowerCase().includes(glossarySearch.toLowerCase()) ||
                    GLOSSARY[term].toLowerCase().includes(glossarySearch.toLowerCase())
                )
                .sort();
            
            return (
                <div className="app">
                    <div className="header">
                        <button className="theme-toggle" onClick={toggleTheme} title={theme === 'dark' ? 'Switch to Light Mode' : 'Switch to Dark Mode'}>
                            {theme === 'dark' ? 'â˜€ï¸' : 'ðŸŒ™'}
                        </button>
                        <h1 className="title">Universus Deck Analyzer</h1>
                        <p className="subtitle">AI-Powered Strategic Analysis</p>
                        {loadedSets.length > 0 && <p className="status">âœ… {loadedSets.length} sets | {Object.keys(cardDatabase).reduce((s, k) => s + cardDatabase[k].length, 0)} cards loaded</p>}
                        {apiKey && <p className="status">ðŸ¤– AI Analysis: Enabled</p>}
                        {beginnerMode && <p className="status">ðŸŽ“ Beginner Mode: Active</p>}
                    </div>
                    
                    <div className="tabs">
                        <button onClick={() => setActiveTab('analyze')} className={`tab ${activeTab === 'analyze' ? 'tab-active' : 'tab-inactive'}`}>Analyze</button>
                        <button onClick={() => setActiveTab('builder')} className={`tab ${activeTab === 'builder' ? 'tab-active' : 'tab-inactive'}`}>âš’ï¸ Build Deck</button>
                        <button onClick={() => setActiveTab('library')} className={`tab ${activeTab === 'library' ? 'tab-active' : 'tab-inactive'}`}>Library ({decks.length})</button>
                        {selectedDeck && <button onClick={() => setActiveTab('view')} className={`tab ${activeTab === 'view' ? 'tab-active' : 'tab-inactive'}`}>View</button>}
                        <button onClick={() => setActiveTab('settings')} className={`tab ${activeTab === 'settings' ? 'tab-active' : 'tab-inactive'}`}>âš™ï¸ Settings</button>
                    </div>
                    
                    {activeTab === 'analyze' && (
                        <div className="card">
                            <h2 style={{fontSize: '1.75rem', fontWeight: 700, marginBottom: '1.5rem'}}>Analyze Deck</h2>
                            {beginnerMode && (
                                <div className="alert alert-info">
                                    ðŸŽ“ <strong>Beginner Mode Active:</strong> Analysis will use simple language with inline definitions for game terms.
                                </div>
                            )}
                            {!apiKey && (
                                <div className="alert alert-info">
                                    ðŸ’¡ Add your Anthropic API key in Settings to enable AI analysis!
                                    <br/><a href="https://console.anthropic.com/" target="_blank">Get API Key â†’</a>
                                </div>
                            )}
                            {Object.keys(cardDatabase).length === 0 && <div className="alert alert-warning">âš ï¸ No sets loaded. Use "Detect Needed Sets".</div>}
                            {error && <div className="alert alert-warning">{error}</div>}
                            {isDetecting && detectProgress.total > 0 && (
                                <div className="progress-box">
                                    <div style={{fontSize: '0.875rem', marginBottom: '0.5rem'}}>Scanning... {detectProgress.current}/{detectProgress.total}</div>
                                    <div className="progress-bar"><div className="progress-fill" style={{width: `${(detectProgress.current / detectProgress.total) * 100}%`}}></div></div>
                                </div>
                            )}
                            {suggestedSets.length > 0 && !isDetecting && (
                                <div className="smart-box">
                                    <div style={{fontWeight: 600, marginBottom: '0.5rem'}}>ðŸŽ¯ Found {suggestedSets.length} sets needed</div>
                                    <div style={{fontSize: '0.875rem'}}>{suggestedSets.map(id => availableSets.find(s => s.id === id)?.name || id).join(', ')}</div>
                                </div>
                            )}
                            <div style={{marginBottom: '1.5rem'}}>
                                <label style={{display: 'block', fontSize: '0.9rem', fontWeight: 600, marginBottom: '0.5rem'}}>Deck Name</label>
                                <input className="input" value={deckName} onChange={e => setDeckName(e.target.value)} placeholder="My Deck" />
                            </div>
                            <div style={{marginBottom: '1.5rem'}}>
                                <label style={{display: 'block', fontSize: '0.9rem', fontWeight: 600, marginBottom: '0.5rem'}}>Deck List</label>
                                <textarea className="textarea" value={deckInput} onChange={e => setDeckInput(e.target.value)} placeholder="1 Character&#10;4 Card Name..." />
                            </div>
                            <button className="btn btn-secondary" onClick={detectNeededSets} disabled={isDetecting || !deckInput.trim()}>
                                {isDetecting ? 'ðŸ” Detecting...' : 'ðŸ” Detect Needed Sets'}
                            </button>
                            {suggestedSets.length > 0 && (
                                <button className="btn btn-primary" onClick={loadSets} disabled={isLoadingSets}>
                                    {isLoadingSets ? 'Loading...' : `Load ${suggestedSets.length} Sets`}
                                </button>
                            )}
                            <button className="btn btn-primary" onClick={analyzeDeck} disabled={isAnalyzing || Object.keys(cardDatabase).length === 0}>
                                {isAnalyzing ? <span>ðŸ¤– Analyzing... <span className="spinner"></span></span> : 'ðŸ¤– Analyze with AI'}
                            </button>
                        </div>
                    )}
                    
                    {activeTab === 'builder' && (() => {
                        const allCards = Object.values(cardDatabase).flat();
                        const characters = allCards.filter(c => c.Cardtype === 'Character');
                        
                        // Get character's symbols
                        const characterSymbols = builderDeck.character?.Symbols || [];
                        
                        // Get all unique symbols from cards
                        const allSymbols = new Set();
                        allCards.forEach(card => {
                            const symbols = card.Symbols || [];
                            symbols.forEach(s => allSymbols.add(s.toLowerCase()));
                        });
                        const uniqueSymbols = Array.from(allSymbols).sort();
                        
                        const filteredCards = allCards.filter(card => {
                            // Don't show characters in card browser
                            if (card.Cardtype === 'Character') return false;
                            
                            // Apply symbol tab filter
                            if (builderFilters.activeSymbolTab !== 'all') {
                                const cardSymbols = (card.Symbols || []).map(s => s.toLowerCase());
                                if (!cardSymbols.includes(builderFilters.activeSymbolTab)) {
                                    return false;
                                }
                            }
                            
                            // Apply symbol filtering (unless "show all" is enabled or browsing tabs)
                            if (!builderFilters.showAllSymbols && builderDeck.character && builderFilters.activeSymbolTab === 'all') {
                                const cardSymbols = card.Symbols || [];
                                
                                // Allow universal cards (with "all" symbol)
                                const isUniversal = cardSymbols.some(s => 
                                    s.toLowerCase() === 'all' || s.toLowerCase() === 'universal' || s.toLowerCase() === 'infinity'
                                );
                                
                                if (!isUniversal) {
                                    // Check if card shares any symbol with character
                                    const hasMatchingSymbol = cardSymbols.some(cardSym => 
                                        characterSymbols.some(charSym => 
                                            cardSym.toLowerCase() === charSym.toLowerCase()
                                        )
                                    );
                                    
                                    if (!hasMatchingSymbol) return false;
                                }
                            }
                            
                            // Apply search filter
                            if (builderSearch && !card.Name.toLowerCase().includes(builderSearch.toLowerCase())) return false;
                            
                            // Apply type filter
                            if (!builderFilters.types.includes(card.Cardtype)) return false;
                            
                            // Apply difficulty filter
                            const diff = card.Difficulty || 0;
                            if (diff < builderFilters.diffMin || diff > builderFilters.diffMax) return false;
                            
                            return true;
                        }).sort((a, b) => a.Name.localeCompare(b.Name));
                        
                        const totalCards = builderDeck.cards.reduce((s, c) => s + c.count, 0) + (builderDeck.character ? 1 : 0);
                        const foundations = builderDeck.cards.filter(c => c.card.Cardtype === 'Foundation');
                        const attacks = builderDeck.cards.filter(c => c.card.Cardtype === 'Attack');
                        const actions = builderDeck.cards.filter(c => c.card.Cardtype === 'Action');
                        const validation = validateBuilderDeck();
                        
                        return (
                            <div>
                                <div style={{display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1.5rem'}}>
                                    <div style={{flex: 1}}>
                                        <h2 style={{fontSize: '1.75rem', fontWeight: 700}}>âš’ï¸ Deck Builder</h2>
                                        <input 
                                            className="input"
                                            value={builderDeck.name}
                                            onChange={e => setBuilderDeck({ ...builderDeck, name: e.target.value })}
                                            placeholder="Deck Name"
                                            style={{marginTop: '0.5rem', maxWidth: '300px'}}
                                        />
                                        
                                        {/* Quick Templates */}
                                        {builderDeck.cards.length === 0 && (
                                            <details style={{marginTop: '0.75rem', fontSize: '0.85rem'}}>
                                                <summary style={{cursor: 'pointer', opacity: 0.8}}>ðŸ’¡ Start from a template...</summary>
                                                <div style={{display: 'flex', gap: '0.5rem', marginTop: '0.5rem', flexWrap: 'wrap'}}>
                                                    {Object.entries(DECK_TEMPLATES).map(([key, template]) => {
                                                        const symbolInfo = SYMBOL_INFO[template.symbol] || {};
                                                        return (
                                                            <div 
                                                                key={key}
                                                                className="card template-card"
                                                                onClick={() => {
                                                                    alert(`Template: ${template.name}\n\n${template.description}\n\nStrategy: ${template.strategy}\n\n(Auto-generation coming in Phase 3!)`);
                                                                }}
                                                                style={{padding: '0.5rem 0.75rem', fontSize: '0.75rem', maxWidth: '150px'}}
                                                            >
                                                                <div style={{fontWeight: 600, marginBottom: '0.25rem'}}>
                                                                    {symbolInfo.emoji || ''} {template.name}
                                                                </div>
                                                                <div style={{opacity: 0.7, fontSize: '0.7rem'}}>
                                                                    {symbolInfo.playstyle || template.symbol}
                                                                </div>
                                                            </div>
                                                        );
                                                    })}
                                                </div>
                                            </details>
                                        )}
                                    </div>
                                    <div style={{display: 'flex', gap: '0.5rem'}}>
                                        <button onClick={clearBuilderDeck} className="btn-secondary btn" style={{width: 'auto', padding: '0.75rem 1.5rem', marginTop: 0}}>Clear</button>
                                        <button onClick={saveBuilderDeck} className="btn-primary btn" style={{width: 'auto', padding: '0.75rem 1.5rem', marginTop: 0}}>Save to Library</button>
                                        <button onClick={analyzeBuilderDeck} className="btn-success btn" style={{width: 'auto', padding: '0.75rem 1.5rem', marginTop: 0}} disabled={!validation.isValid}>ðŸ¤– Analyze</button>
                                    </div>
                                </div>
                                
                                {Object.keys(cardDatabase).length === 0 && (
                                    <div className="alert alert-warning">âš ï¸ No card sets loaded. Go to Settings and load sets first!</div>
                                )}
                                
                                {Object.keys(cardDatabase).length > 0 && !builderDeck.character && (
                                    <div className="alert alert-info">ðŸ’¡ Select a character first to see which cards you can legally play!</div>
                                )}
                                
                                <div className="builder-container">
                                    {/* Left Panel - Card Browser */}
                                    <div className="builder-panel card">
                                        <h3 style={{fontSize: '1.25rem', fontWeight: 700, marginBottom: '1rem'}}>Card Browser</h3>
                                        
                                        {/* Symbol Tabs */}
                                        {uniqueSymbols.length > 0 && (
                                            <div style={{marginBottom: '1rem', padding: '0.5rem', borderRadius: '8px', border: '1px solid'}}>
                                                <div style={{fontSize: '0.75rem', fontWeight: 600, marginBottom: '0.5rem', opacity: 0.8}}>
                                                    Browse by Symbol:
                                                </div>
                                                <div style={{display: 'flex', gap: '0.5rem', flexWrap: 'wrap'}}>
                                                    <button
                                                        onClick={() => setBuilderFilters({ ...builderFilters, activeSymbolTab: 'all' })}
                                                        className={builderFilters.activeSymbolTab === 'all' ? 'btn-primary' : 'btn-secondary'}
                                                        style={{padding: '0.4rem 0.8rem', fontSize: '0.8rem', marginTop: 0, width: 'auto'}}
                                                    >
                                                        All
                                                    </button>
                                                    {uniqueSymbols.map(symbol => {
                                                        const info = SYMBOL_INFO[symbol] || {};
                                                        return (
                                                            <button
                                                                key={symbol}
                                                                onClick={() => setBuilderFilters({ ...builderFilters, activeSymbolTab: symbol })}
                                                                className={builderFilters.activeSymbolTab === symbol ? 'btn-primary' : 'btn-secondary'}
                                                                style={{padding: '0.4rem 0.8rem', fontSize: '0.8rem', marginTop: 0, width: 'auto'}}
                                                                title={info.name || symbol}
                                                            >
                                                                {info.emoji || ''} {(info.name || symbol).charAt(0).toUpperCase() + (info.name || symbol).slice(1)}
                                                            </button>
                                                        );
                                                    })}
                                                </div>
                                            </div>
                                        )}
                                        
                                        <input
                                            type="text"
                                            className="builder-search input"
                                            placeholder="Search cards..."
                                            value={builderSearch}
                                            onChange={e => setBuilderSearch(e.target.value)}
                                        />
                                        
                                        <div className="builder-filters">
                                            <div className="builder-filter-group">
                                                <span className="builder-filter-label">Card Types</span>
                                                <div style={{display: 'flex', gap: '0.5rem'}}>
                                                    {['Attack', 'Foundation', 'Action'].map(type => (
                                                        <label key={type} style={{display: 'flex', alignItems: 'center', gap: '0.25rem', fontSize: '0.85rem'}}>
                                                            <input
                                                                type="checkbox"
                                                                checked={builderFilters.types.includes(type)}
                                                                onChange={e => {
                                                                    if (e.target.checked) {
                                                                        setBuilderFilters({ ...builderFilters, types: [...builderFilters.types, type] });
                                                                    } else {
                                                                        setBuilderFilters({ ...builderFilters, types: builderFilters.types.filter(t => t !== type) });
                                                                    }
                                                                }}
                                                            />
                                                            {type}
                                                        </label>
                                                    ))}
                                                </div>
                                            </div>
                                            
                                            <div className="builder-filter-group">
                                                <span className="builder-filter-label">Difficulty: {builderFilters.diffMin}-{builderFilters.diffMax}</span>
                                                <div style={{display: 'flex', gap: '0.5rem'}}>
                                                    <input
                                                        type="range"
                                                        min="0"
                                                        max="10"
                                                        value={builderFilters.diffMin}
                                                        onChange={e => setBuilderFilters({ ...builderFilters, diffMin: parseInt(e.target.value) })}
                                                        className="range-slider"
                                                        style={{width: '80px'}}
                                                    />
                                                    <input
                                                        type="range"
                                                        min="0"
                                                        max="10"
                                                        value={builderFilters.diffMax}
                                                        onChange={e => setBuilderFilters({ ...builderFilters, diffMax: parseInt(e.target.value) })}
                                                        className="range-slider"
                                                        style={{width: '80px'}}
                                                    />
                                                </div>
                                            </div>
                                            
                                            {builderDeck.character && (
                                                <div className="builder-filter-group">
                                                    <span className="builder-filter-label">Symbol Filter</span>
                                                    <label style={{display: 'flex', alignItems: 'center', gap: '0.25rem', fontSize: '0.85rem'}}>
                                                        <input
                                                            type="checkbox"
                                                            checked={builderFilters.showAllSymbols}
                                                            onChange={e => setBuilderFilters({ ...builderFilters, showAllSymbols: e.target.checked })}
                                                        />
                                                        Show all symbols
                                                    </label>
                                                </div>
                                            )}
                                        </div>
                                        
                                        <div style={{fontSize: '0.85rem', opacity: 0.8, marginBottom: '0.75rem'}}>
                                            {filteredCards.length} cards
                                        </div>
                                        
                                        <div className="card-browser">
                                            {filteredCards.slice(0, 100).map(card => {
                                                const cardSymbols = card.Symbols || [];
                                                const symbolDisplay = cardSymbols.length > 0 
                                                    ? cardSymbols.map(s => {
                                                        const info = SYMBOL_INFO[s.toLowerCase()];
                                                        return info ? `${info.emoji} ${info.name}` : s.charAt(0).toUpperCase() + s.slice(1);
                                                    }).join(', ')
                                                    : 'None';
                                                
                                                return (
                                                    <div key={card.Name + card.setId} className="card-row card">
                                                        <div className="card-info">
                                                            <div className="card-name">{card.Name}</div>
                                                            <div className="card-stats">
                                                                {card.Cardtype} â€¢ 
                                                                {card.Difficulty != null && ` Diff: ${card.Difficulty} â€¢`}
                                                                {card.Check != null && ` Ctrl: ${card.Check} â€¢`}
                                                                {card.Speed != null && ` Spd: ${card.Speed} â€¢`}
                                                                {` ${symbolDisplay}`}
                                                            </div>
                                                        </div>
                                                        <button onClick={() => addCardToBuilder(card)} className="card-add-btn btn-primary">+</button>
                                                    </div>
                                                );
                                            })}
                                            {filteredCards.length > 100 && (
                                                <div style={{textAlign: 'center', padding: '1rem', opacity: 0.6}}>
                                                    Showing first 100 cards. Refine your search to see more.
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                    
                                    {/* Right Panel - Deck List */}
                                    <div className="builder-panel card">
                                        <h3 style={{fontSize: '1.25rem', fontWeight: 700, marginBottom: '1rem'}}>
                                            Your Deck ({totalCards}/60)
                                        </h3>
                                        
                                        {/* Deck Stats */}
                                        {builderDeck.cards.length > 0 && (() => {
                                            const stats = calculateDeckStats();
                                            const maxDistValue = Math.max(...Object.values(stats.distribution));
                                            const hints = getDeckSynergyHints();
                                            
                                            return (
                                                <>
                                                    {/* Synergy Hints */}
                                                    {hints.length > 0 && (
                                                        <div style={{marginBottom: '1rem'}}>
                                                            {hints.map((hint, i) => (
                                                                <div 
                                                                    key={i}
                                                                    className="card"
                                                                    style={{
                                                                        padding: '0.75rem',
                                                                        marginBottom: '0.5rem',
                                                                        fontSize: '0.8rem',
                                                                        borderLeft: `3px solid ${
                                                                            hint.type === 'success' ? '#14b8a6' :
                                                                            hint.type === 'warning' ? '#f59e0b' :
                                                                            '#3b82f6'
                                                                        }`
                                                                    }}
                                                                >
                                                                    {hint.type === 'success' ? 'âœ…' : hint.type === 'warning' ? 'âš ï¸' : 'ðŸ’¡'} {hint.text}
                                                                </div>
                                                            ))}
                                                        </div>
                                                    )}
                                                    
                                                    <div className="card" style={{padding: '1rem', marginBottom: '1rem'}}>
                                                    <div style={{fontSize: '0.9rem', fontWeight: 700, marginBottom: '0.75rem'}}>
                                                        ðŸ“Š Deck Statistics
                                                    </div>
                                                    
                                                    <div style={{fontSize: '0.8rem', marginBottom: '0.5rem'}}>
                                                        <strong>Curve Speed:</strong> {stats.curveSpeed === 'AGGRO' ? 'âš¡' : stats.curveSpeed === 'CONTROL' ? 'ðŸ›¡ï¸' : 'âš–ï¸'} {stats.curveSpeed}
                                                    </div>
                                                    
                                                    <div style={{fontSize: '0.8rem', marginBottom: '0.5rem'}}>
                                                        <strong>Avg Difficulty:</strong> {stats.avgDiff}
                                                    </div>
                                                    
                                                    <div style={{fontSize: '0.75rem', marginBottom: '0.5rem', opacity: 0.9}}>
                                                        Foundations: {stats.foundationCount} â€¢ Attacks: {stats.attackCount} â€¢ Actions: {stats.actionCount}
                                                    </div>
                                                    
                                                    <details style={{fontSize: '0.75rem', marginTop: '0.5rem'}}>
                                                        <summary style={{cursor: 'pointer', fontWeight: 600}}>Difficulty Distribution â–¼</summary>
                                                        <div style={{marginTop: '0.5rem', paddingLeft: '0.5rem'}}>
                                                            {Object.entries(stats.distribution).map(([range, count]) => {
                                                                const percentage = maxDistValue > 0 ? (count / maxDistValue) * 100 : 0;
                                                                return (
                                                                    <div key={range} style={{marginBottom: '0.25rem'}}>
                                                                        <div style={{display: 'flex', justifyContent: 'space-between', fontSize: '0.7rem', marginBottom: '0.1rem'}}>
                                                                            <span>Diff {range}:</span>
                                                                            <span>{count} cards</span>
                                                                        </div>
                                                                        <div style={{width: '100%', height: '4px', background: 'rgba(255,255,255,0.1)', borderRadius: '2px', overflow: 'hidden'}}>
                                                                            <div style={{width: `${percentage}%`, height: '100%', background: '#14b8a6', transition: 'width 0.3s'}}></div>
                                                                        </div>
                                                                    </div>
                                                                );
                                                            })}
                                                        </div>
                                                    </details>
                                                    
                                                    {Object.keys(stats.symbolCounts).length > 0 && (
                                                        <details style={{fontSize: '0.75rem', marginTop: '0.5rem'}}>
                                                            <summary style={{cursor: 'pointer', fontWeight: 600}}>Symbol Distribution â–¼</summary>
                                                            <div style={{marginTop: '0.5rem', paddingLeft: '0.5rem'}}>
                                                                {Object.entries(stats.symbolCounts).map(([symbol, count]) => {
                                                                    const info = SYMBOL_INFO[symbol] || {};
                                                                    const percentage = ((count / (totalCards - 1)) * 100).toFixed(0);
                                                                    return (
                                                                        <div key={symbol} style={{marginBottom: '0.25rem', fontSize: '0.7rem'}}>
                                                                            {info.emoji || ''} {info.name || symbol}: {count} cards ({percentage}%)
                                                                        </div>
                                                                    );
                                                                })}
                                                            </div>
                                                        </details>
                                                    )}
                                                </div>
                                                </>
                                            );
                                        })()}
                                        
                                        {/* Validation */}
                                        {(validation.errors.length > 0 || validation.warnings.length > 0) && (
                                            <div className="validation-box card">
                                                {validation.errors.map((err, i) => (
                                                    <div key={i} className="validation-error" style={{color: '#ef4444'}}>âŒ {err}</div>
                                                ))}
                                                {validation.warnings.map((warn, i) => (
                                                    <div key={i} className="validation-warning" style={{color: '#f59e0b'}}>âš ï¸ {warn}</div>
                                                ))}
                                            </div>
                                        )}
                                        
                                        {/* Character */}
                                        <div className="char-selector card">
                                            <label className="char-selector-label">Character (1/1)</label>
                                            <select 
                                                className="input"
                                                value={builderDeck.character?.Name || ''}
                                                onChange={e => {
                                                    const char = characters.find(c => c.Name === e.target.value);
                                                    setBuilderCharacter(char || null);
                                                }}
                                            >
                                                <option value="">Select Character...</option>
                                                {characters.map(char => (
                                                    <option key={char.Name + char.setId} value={char.Name}>
                                                        {char.Name} {char.Symbols && char.Symbols.length > 0 && `(${char.Symbols.join(', ')})`}
                                                    </option>
                                                ))}
                                            </select>
                                            
                                            {builderDeck.character && (
                                                <div style={{marginTop: '0.75rem'}}>
                                                    <div style={{padding: '0.75rem', borderRadius: '6px', fontSize: '0.85rem', marginBottom: '0.75rem'}}>
                                                        <strong>Symbols:</strong> {characterSymbols.map(s => s.charAt(0).toUpperCase() + s.slice(1)).join(', ')}
                                                        <br/>
                                                        <span style={{opacity: 0.8, fontSize: '0.8rem'}}>
                                                            {builderFilters.showAllSymbols 
                                                                ? 'âš ï¸ Showing all cards (some may be illegal)'
                                                                : 'âœ… Only showing legal cards for this character'
                                                            }
                                                        </span>
                                                    </div>
                                                    
                                                    {/* Symbol Strategy Info */}
                                                    {characterSymbols.length > 0 && characterSymbols.map(symbol => {
                                                        const symbolKey = symbol.toLowerCase();
                                                        const info = SYMBOL_INFO[symbolKey] || SYMBOL_INFO['infinity'];
                                                        if (!info) return null;
                                                        
                                                        return (
                                                            <div key={symbol} className="card" style={{padding: '1rem', marginBottom: '0.75rem'}}>
                                                                <div style={{fontSize: '1rem', fontWeight: 700, marginBottom: '0.5rem'}}>
                                                                    {info.emoji} {info.name} Strategy
                                                                </div>
                                                                <div style={{fontSize: '0.85rem', marginBottom: '0.5rem', fontWeight: 600, opacity: 0.9}}>
                                                                    {info.playstyle}
                                                                </div>
                                                                <div style={{fontSize: '0.8rem', lineHeight: 1.5, marginBottom: '0.75rem'}}>
                                                                    {info.description}
                                                                </div>
                                                                
                                                                <details style={{fontSize: '0.75rem', marginTop: '0.5rem'}}>
                                                                    <summary style={{cursor: 'pointer', fontWeight: 600, marginBottom: '0.5rem'}}>
                                                                        Show Details â–¼
                                                                    </summary>
                                                                    <div style={{paddingLeft: '1rem'}}>
                                                                        <div style={{marginBottom: '0.5rem'}}>
                                                                            <strong>Mechanics:</strong>
                                                                            <ul style={{marginTop: '0.25rem', marginLeft: '1rem'}}>
                                                                                {info.mechanics.map((m, i) => (
                                                                                    <li key={i} style={{marginBottom: '0.15rem'}}>{m}</li>
                                                                                ))}
                                                                            </ul>
                                                                        </div>
                                                                        <div style={{marginBottom: '0.5rem'}}>
                                                                            <strong>âœ… Strengths:</strong>
                                                                            <ul style={{marginTop: '0.25rem', marginLeft: '1rem'}}>
                                                                                {info.strengths.map((s, i) => (
                                                                                    <li key={i} style={{marginBottom: '0.15rem'}}>{s}</li>
                                                                                ))}
                                                                            </ul>
                                                                        </div>
                                                                        <div style={{marginBottom: '0.5rem'}}>
                                                                            <strong>âŒ Weaknesses:</strong>
                                                                            <ul style={{marginTop: '0.25rem', marginLeft: '1rem'}}>
                                                                                {info.weaknesses.map((w, i) => (
                                                                                    <li key={i} style={{marginBottom: '0.15rem'}}>{w}</li>
                                                                                ))}
                                                                            </ul>
                                                                        </div>
                                                                        <div style={{marginBottom: '0.5rem'}}>
                                                                            <strong>ðŸ’¡ Recommended for:</strong> {info.recommendedFor}
                                                                        </div>
                                                                        <div>
                                                                            <strong>ðŸŽ¯ Archetypes:</strong> {info.archetypes.join(', ')}
                                                                        </div>
                                                                    </div>
                                                                </details>
                                                            </div>
                                                        );
                                                    })}
                                                </div>
                                            )}
                                        </div>
                                        
                                        {/* Foundations */}
                                        {foundations.length > 0 && (
                                            <div className="deck-section">
                                                <div className="deck-section-title">
                                                    Foundations ({foundations.reduce((s, c) => s + c.count, 0)})
                                                </div>
                                                {foundations.map(entry => (
                                                    <div key={entry.card.Name} className="deck-card-row card">
                                                        <div className="deck-card-name">{entry.card.Name}</div>
                                                        <div className="deck-card-controls">
                                                            <button onClick={() => removeCardFromBuilder(entry.card)} className="deck-btn-small btn-secondary">-</button>
                                                            <span className="deck-card-count">{entry.count}x</span>
                                                            <button onClick={() => addCardToBuilder(entry.card)} className="deck-btn-small btn-primary" disabled={entry.count >= 4}>+</button>
                                                        </div>
                                                    </div>
                                                ))}
                                            </div>
                                        )}
                                        
                                        {/* Attacks */}
                                        {attacks.length > 0 && (
                                            <div className="deck-section">
                                                <div className="deck-section-title">
                                                    Attacks ({attacks.reduce((s, c) => s + c.count, 0)})
                                                </div>
                                                {attacks.map(entry => (
                                                    <div key={entry.card.Name} className="deck-card-row card">
                                                        <div className="deck-card-name">{entry.card.Name}</div>
                                                        <div className="deck-card-controls">
                                                            <button onClick={() => removeCardFromBuilder(entry.card)} className="deck-btn-small btn-secondary">-</button>
                                                            <span className="deck-card-count">{entry.count}x</span>
                                                            <button onClick={() => addCardToBuilder(entry.card)} className="deck-btn-small btn-primary" disabled={entry.count >= 4}>+</button>
                                                        </div>
                                                    </div>
                                                ))}
                                            </div>
                                        )}
                                        
                                        {/* Actions */}
                                        {actions.length > 0 && (
                                            <div className="deck-section">
                                                <div className="deck-section-title">
                                                    Actions ({actions.reduce((s, c) => s + c.count, 0)})
                                                </div>
                                                {actions.map(entry => (
                                                    <div key={entry.card.Name} className="deck-card-row card">
                                                        <div className="deck-card-name">{entry.card.Name}</div>
                                                        <div className="deck-card-controls">
                                                            <button onClick={() => removeCardFromBuilder(entry.card)} className="deck-btn-small btn-secondary">-</button>
                                                            <span className="deck-card-count">{entry.count}x</span>
                                                            <button onClick={() => addCardToBuilder(entry.card)} className="deck-btn-small btn-primary" disabled={entry.count >= 4}>+</button>
                                                        </div>
                                                    </div>
                                                ))}
                                            </div>
                                        )}
                                        
                                        {builderDeck.cards.length === 0 && (
                                            <div style={{textAlign: 'center', padding: '3rem', opacity: 0.6}}>
                                                Add cards from the browser to start building your deck!
                                            </div>
                                        )}
                                    </div>
                                </div>
                            </div>
                        );
                    })()}
                    
                    {activeTab === 'library' && (
                        <div className="card">
                            <h2 style={{fontSize: '1.75rem', fontWeight: 700, marginBottom: '1.5rem'}}>Library</h2>
                            {decks.length === 0 ? (
                                <div style={{textAlign: 'center', padding: '4rem'}}>No decks yet!</div>
                            ) : (
                                <div style={{display: 'flex', flexDirection: 'column', gap: '1rem'}}>
                                    {decks.map(deck => (
                                        <div key={deck.id} onClick={() => { setSelectedDeck(deck); setActiveAnalysisTab(0); setActiveTab('view'); }} style={{borderRadius: '10px', padding: '1.25rem', cursor: 'pointer', transition: 'all 0.2s', border: '1px solid'}}>
                                            <div style={{display: 'flex', justifyContent: 'space-between'}}>
                                                <div>
                                                    <h3 style={{fontSize: '1.375rem', fontWeight: 700}}>{deck.name}</h3>
                                                    <p style={{fontSize: '0.75rem', marginTop: '0.25rem'}}>{new Date(deck.createdAt).toLocaleDateString()}</p>
                                                </div>
                                                <button onClick={e => { e.stopPropagation(); if(confirm('Delete?')) { setDecks(decks.filter(d => d.id !== deck.id)); setSelectedDeck(null); }}} style={{padding: '0.625rem 1.25rem', border: 'none', borderRadius: '8px', cursor: 'pointer'}}>Delete</button>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            )}
                        </div>
                    )}
                    
                    {activeTab === 'view' && selectedDeck && (() => {
                        const sections = parseAnalysis(selectedDeck.analysis);
                        return (
                            <div className="card">
                                {beginnerMode && (
                                    <div className="beginner-badge">ðŸŽ“ Beginner Mode Active - Inline definitions included</div>
                                )}
                                <div style={{display: 'flex', justifyContent: 'space-between', marginBottom: '1.5rem'}}>
                                    <h2 style={{fontSize: '1.75rem', fontWeight: 700}}>{selectedDeck.name}</h2>
                                    <button onClick={() => setActiveTab('library')} style={{padding: '0.625rem 1.25rem', border: 'none', borderRadius: '8px', cursor: 'pointer'}} className="btn-secondary">â† Back</button>
                                </div>
                                <div style={{marginBottom: '2rem'}}>
                                    <h3 style={{fontSize: '1.25rem', fontWeight: 700, marginBottom: '1rem'}}>Deck List</h3>
                                    <pre style={{borderRadius: '8px', padding: '1.5rem', fontFamily: 'monospace', fontSize: '0.875rem', whiteSpace: 'pre-wrap', border: '1px solid'}}>{selectedDeck.deckList}</pre>
                                </div>
                                <div>
                                    <h3 style={{fontSize: '1.25rem', fontWeight: 700, marginBottom: '1rem'}}>ðŸ¤– AI Strategic Analysis</h3>
                                    
                                    <div className="analysis-tabs">
                                        {sections.map((section, idx) => (
                                            <button key={idx} onClick={() => setActiveAnalysisTab(idx)} className={`analysis-tab ${activeAnalysisTab === idx ? 'analysis-tab-active' : 'analysis-tab-inactive'}`}>
                                                {section.title}
                                            </button>
                                        ))}
                                    </div>
                                    
                                    <div className="card" style={{marginTop: 0}}>
                                        {sections[activeAnalysisTab].title === 'ðŸ“– Glossary' ? (
                                            <div className="analysis">
                                                <h1>ðŸ“– Game Terms Glossary</h1>
                                                <input 
                                                    type="text"
                                                    className="glossary-search input"
                                                    placeholder="Search terms..."
                                                    value={glossarySearch}
                                                    onChange={e => setGlossarySearch(e.target.value)}
                                                />
                                                <div className="glossary-section">
                                                    {filteredGlossary.map(term => (
                                                        <div key={term}>
                                                            <div className="glossary-term">ðŸ“˜ {term}</div>
                                                            <div className="glossary-definition">{GLOSSARY[term]}</div>
                                                        </div>
                                                    ))}
                                                    {filteredGlossary.length === 0 && (
                                                        <div style={{textAlign: 'center', padding: '2rem', color: '#94a3b8'}}>
                                                            No terms found matching "{glossarySearch}"
                                                        </div>
                                                    )}
                                                </div>
                                            </div>
                                        ) : (
                                            <div className="analysis" dangerouslySetInnerHTML={{ __html: marked.parse(sections[activeAnalysisTab].content) }} />
                                        )}
                                    </div>
                                </div>
                            </div>
                        );
                    })()}
                    
                    {activeTab === 'settings' && (
                        <div className="card">
                            <h2 style={{fontSize: '1.75rem', fontWeight: 700, marginBottom: '1.5rem'}}>Settings</h2>
                            
                            <div className="api-key-section">
                                <h3 style={{fontSize: '1.25rem', fontWeight: 700, marginBottom: '1rem'}}>ðŸŽ“ Beginner Mode</h3>
                                <p style={{marginBottom: '1rem', lineHeight: 1.6}}>
                                    Enable beginner-friendly mode for simplified analysis with inline definitions.
                                </p>
                                <div className="beginner-toggle smart-box">
                                    <label className="toggle-switch">
                                        <input type="checkbox" checked={beginnerMode} onChange={e => setBeginnerMode(e.target.checked)} />
                                        <span className="toggle-slider"></span>
                                    </label>
                                    <div>
                                        <div style={{fontWeight: 600, marginBottom: '0.25rem'}}>
                                            {beginnerMode ? 'ðŸŽ“ Beginner Mode ON' : 'âš”ï¸ Advanced Mode'}
                                        </div>
                                        <div style={{fontSize: '0.875rem', opacity: 0.8}}>
                                            {beginnerMode ? 'Simple language, inline definitions, and step-by-step guides' : 'Detailed strategic analysis for experienced players'}
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <div className="api-key-section">
                                <h3 style={{fontSize: '1.25rem', fontWeight: 700, marginBottom: '1rem'}}>ðŸ¤– AI Setup</h3>
                                <p style={{marginBottom: '1rem', lineHeight: 1.6}}>Add your Anthropic API key for AI strategic analysis.</p>
                                <p style={{marginBottom: '1rem', fontSize: '0.875rem'}}>
                                    Get API key: <a href="https://console.anthropic.com/" target="_blank">console.anthropic.com</a>
                                    <br/>Cost: ~$0.03-0.05 per analysis
                                </p>
                                {apiKey ? (
                                    <div className="alert alert-success">
                                        âœ… API Key configured!
                                        <button onClick={clearApiKey} style={{marginTop: '0.75rem', padding: '0.5rem 1rem', border: 'none', borderRadius: '6px', cursor: 'pointer', display: 'block'}}>Remove Key</button>
                                    </div>
                                ) : (
                                    <div>
                                        <input type="password" className="input" value={apiKeyInput} onChange={e => setApiKeyInput(e.target.value)} placeholder="sk-ant-..." style={{marginBottom: '0.75rem'}} />
                                        <button onClick={saveApiKey} disabled={!apiKeyInput.trim()} className="btn btn-success">Save API Key</button>
                                    </div>
                                )}
                            </div>
                            
                            <h3 style={{fontSize: '1.25rem', fontWeight: 700, marginBottom: '1rem'}}>ðŸ“¦ Card Sets</h3>
                            <p style={{marginBottom: '1rem'}}>{availableSets.length} sets available</p>
                            
                            {loadedSets.length > 0 && (
                                <button onClick={debugCardStructure} className="btn btn-secondary" style={{marginBottom: '1rem'}}>
                                    ðŸ” Debug: Show Card Structure
                                </button>
                            )}
                            
                            <div style={{display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(200px, 1fr))', gap: '0.5rem', maxHeight: '400px', overflow: 'auto', padding: '0.5rem', borderRadius: '8px', marginBottom: '1.5rem', border: '1px solid'}}>
                                {availableSets.map(set => (
                                    <label key={set.id} style={{display: 'flex', alignItems: 'center', gap: '0.75rem', padding: '0.75rem', border: '1px solid', borderRadius: '6px', cursor: 'pointer'}}>
                                        <input type="checkbox" checked={selectedSets.includes(set.id)} onChange={e => setSelectedSets(e.target.checked ? [...selectedSets, set.id] : selectedSets.filter(id => id !== set.id))} style={{width: '1.125rem', height: '1.125rem'}} />
                                        <span style={{fontSize: '0.875rem', fontWeight: 600}}>{set.name || set.id}</span>
                                        {loadedSets.includes(set.id) && <span style={{fontSize: '0.75rem', marginLeft: 'auto'}}>âœ“</span>}
                                    </label>
                                ))}
                            </div>
                            <button className="btn btn-primary" onClick={loadSets} disabled={isLoadingSets || selectedSets.length === 0}>
                                {isLoadingSets ? `Loading (${loadedSets.length}/${selectedSets.length})...` : `Load ${selectedSets.length} Sets`}
                            </button>
                        </div>
                    )}
                </div>
            );
        }
        
        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
